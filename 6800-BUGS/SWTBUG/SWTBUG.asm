 NAM SWTBUG
*      VERSION 1.00

* OPT PAG
****************************************************
*REPLACEMENT FOR MIKBUG ROM
*FOR SWTPC 6800 COMPUTER SYSTEM
*COPYRIGHT 1977
*SOUTHWEST TECHNICAL PROD. CORP.
*AUGUST, 1977
****************************************************


 ORG $A000
IRQ RMB 2 IRQ POINTER
BEGA RMB 2 BEGINNING ADDR PNCH
ENDA RMB 2 ENDING ADDR PNCH
NMI RMB 2 NMI INTERRUPT VECTOR
SP RMB 1 S HIGH
 RMB 1 S LOW
PORADD RMB 2 PORT ADDRESS
PORECH RMB 1 ECHO ON/OFF FLAG
XHI RMB 1 XREG HIGH
XLOW RMB 1 XREG LOW
CKSM RMB 1 CHECKSUM
XTEMP RMB 2 X-REG TEMP STGE
SWIJMP RMB 2 SWI JUMP VECTOR
TW EQU $A044 TEMPORARY STORAGE
TEMP EQU $A046 TEMPORARY STORAGE
BYTECT EQU $A047 BYTECT AND MCONT TEMP.
CTLPOR EQU $8004 CONTROL PORT ADDRESS
PROM EQU $C000 JUMP TO PROM ADDRESS
BKPT RMB 2 BREAKPOINT ADDRESS
BKLST RMB 1 BREAKPOINT DATA

 ORG $A042
STACK RMB 1 SWTBUG STACK

 ORG $E000

*I/O INTERRUPT SEQUENCE
IRQV LDX IRQ
 JMP 0,X

*JUMP TO USER PROGRAM
JUMP BSR BADDR
 JMP 0,X

CURSOR FCB $10,$16,4 CT-1024 CURSOR CONTROL

*ASCII LOADING ROUTINE
LOAD JSR RDON READER ON, DIS ECHO, GET P#
LOAD3 BSR INCH
 CMPA #'S
 BNE LOAD3 1ST CHAR NOT S
 BSR INCH READ CHAR
 CMPA #'9
 BEQ LOAD21
 CMPA #'1
 BNE LOAD3 2ND CHAR NOT 1
 CLR CKSM ZERO CHECKSUM
 BSR BYTE READ BYTE
 SUBA #2
 STAA BYTECT BYTE COUNT
*BUILD ADDRESS
 BSR BADDR
*STORE DATA
LOAD11 BSR BYTE
 DEC BYTECT
 BEQ LOAD15 ZERO BYTE COUNT
 STAA 0,X STORE DATA
 CMPA 0,X DATA STORED?
 BNE LOAD19
 INX
 BRA LOAD11
LOAD15 INC CKSM
 BEQ LOAD3
LOAD19 LDAA #'?
 BSR OUTCH
LOAD21 JMP RDOFF1

*BUILD ADDRESS
BADDR BSR BYTE READ 2 FRAMES
 STAA XHI
 BSR BYTE
 STAA XLOW
 LDX XHI LOAD IXR WITH NUMBER
 RTS

*INPUT BYTE (TWO FRAMES)
BYTE BSR INHEX GET HEX CHAR
BYTE1 ASLA
 ASLA
 ASLA
 ASLA
 TAB
 BSR INHEX
 ABA
 TAB
 ADDB CKSM
 STAB CKSM
 RTS

OUTHL LSRA OUT HEX LEFT BCD DIGIT
 LSRA
 LSRA
 LSRA
OUTHR ANDA #$F OUT HEX RIGHT BCD DIGIT
 ADDA #$30
 CMPA #$39
 BLS OUTCH
 ADDA #$7

*OUTPUT ONE CHAR
OUTCH JMP OUTEEE
INCH JMP INEEE

*PRINT DATA POINTED TO BY X REG
PDATA2 BSR OUTCH
 INX
PDATA1 LDAA 0,X
 CMPA #4
 BNE PDATA2
 RTS STOP ON HEX 04

C1 JMP SWTCTL

*MEMORY EXAMINE AND CHANGE
CHANGE BSR BADDR
CHA51 LDX #MCL
 BSR PDATA1 C/R L/F
 LDX #XHI
 BSR OUT4HS PRINT ADDRESS
 LDX XHI
 BSR OUT2HS PRINT OLD DATA
 BSR OUTS OUTPUT SPACE
ANOTH BSR INCH INPUT CHAR
 CMPA #$20
 BEQ ANOTH
 CMPA #$D
 BEQ C1
 CMPA #'^ UP ARROW?
 BRA AL3 BRANCH FOR ADJUSTMENT
 NOP

*INPUT HEX CHARACTER
INHEX BSR INCH
INHEX1 SUBA #$30
 BMI C3
 CMPA #$9
 BLE IN1HG
 CMPA #$11
 BMI C3 NOT HEX
 CMPA #$16
 BGT C3 NOT HEX
 SUBA #7
IN1HG RTS

OUT2H LDAA 0,X OUTPUT 2 HEX CHAR
OUT2HA BSR OUTHL OUT LEFT HEX CHAR
 LDAA 0,X
 INX
 BRA OUTHR OUTPUT RIGHT HEX CHAR

OUT4HS BSR OUT2H OUTPUT 4 HEX CHAR + SPACE
OUT2HS BSR OUT2H OUTPUT 2 HEX CHAR + SPACE

OUTS LDAA #$20 SPACE
 BRA OUTCH (BSR & TRS)

*ENTER POWER ON SEQUENCE
START LDS #STACK
 BRA AL1 BRANCH FOR ADDRESS COMPATIBIL

********************************************
*PART OF MEMORY EXAMINE AND CHANGE
AL3 BNE SK1
 DEX
 DEX
 STX XHI
 BRA CHA51
SK1 STX XHI
 BRA AL4

EOE3 BRA CONTRL BRANCH FOR MIKBUG EQUIV. CONT

AL4 CMPA #$30
 BCS CHA51
 CMPA #$46
 BHI CHA51
 BSR INHEX1
 JSR BYTE1
 DEX
 STAA 0,X CHANGE MEMORY
 CMPA 0,X
 BEQ CHA51 DID CHANGE
 JMP LOAD19 DIDN'T CHANGE
C3 LDS SP
 BRA SWTCTL
**************************************************

*CONTINUE POWER UP SEQUENCE
AL1 STS SP INIT TARGET STACK PTR.
 LDAA #$FF
 JSR SWISET
*CONFIGURE FOR PIA AND SEE IF OK
 LDX #CTLPOR
 JSR PIAINI INIT PIA
 LDAA 0,X
 CMPA 2,X
 BRA AL2

 BRA PRINT BRA FOR BILOAD

AL2 BNE CONTRL

*INITIALIZE AS ACIA
 LDAA #3 ACIA MASTER RESET
 STAA 0,X
 LDAA #$11
 STAA 0,X
 BRA CONTRL

*ENTER FROM SOFTWARE INTERRUPT
SF0 NOP
SFE1 STS SP SAVE TARGETS STACK POINTER
*DECREMENT P COUNTER
 TSX
 TST 6,X
 BNE *+4
 DEC 5,X
 DEC 6,X
*PRINT CONTENTS OF STACK.
PRINT LDX #MCL
 JSR PDATA1
 LDX SP
 INX
 BSR OUT2HS COND CODES
 BSR OUT2HS ACC B
 BSR OUT2HS ACC A
 BSR OUT4HS IXR
 BSR OUT4HS PGM COUNTER
 LDX #SP
 JSR OUT4HS STACK POINTER
SWTCTL LDX SWIJMP
 CPX #SF0
 BEQ CONTR1

CONTRL LDS #STACK SET CONTRL STACK POINTER
 LDX #CTLPOR RESET TO CONTROL PORT
 STX PORADD
 CLR PORECH TURN ECHO ON
 BSR SAVGET GET PORT # AND TYPE
 BEQ POF1
 JSR PIAECH SET PIA ECHO ON IF MP-C INTER
POF1 JSR PNCHOF TURN PUNCH OFF
 JSR RDOFF TURN READER OFF
CONTR1 LDX #MCLOFF
 JSR PDATA1 PRINT DATA STRING
 BSR INEEE READ COMMAND CHARACTER

*COMMAND LOOKUP ROUTINE
LOOK LDX #TABLE
OVER CMPA 0,X
 BNE SK3
 JSR OUTS SKIP SPACE
 LDX 1,X
 JMP 0,X
SK3 INX
 INX
 INX
 CPX #TABEND+3
 BNE OVER
SWTL1 BRA SWTCTL

*SOFTWARE INTERRUPT ENTRY POINT
SFE LDX SWIJMP JUMP TO VECTORED SOFTWARE INT
 JMP 0,X

S9 FCB 'S,'9,4 END OF TAPE

***************************************************
MTAPE1 FCB $D,$A,$15,0,0,0,'S,'1,4 PUNCH FORMAT

MCLOFF FCB $13 READER OFF
MCL FCB $D,$A,$15,0,0,0,'$,4

EIA5 BRA BILD BINARY LOADER INPUT
***************************************************


*NMI SEQUENCE
NMIV LDX NMI GET NMI VECTOR
 JMP 0,X

INEEE BRA INEEE1

*BYTE SEARCH ROUTINE
SEARCH JSR BADDR GET TOP ADDRESS
 STX ENDA
 JSR BADDR GET BOTTOM ADDRESS
 JSR BYTE GET BYTE TO SEARCH FOR
 TAB
OVE LDAA 0,X
 STX XHI
 CBA
 BEQ PNT
 BRA INCR1
PNT LDX #MCL
 JSR PDATA1
 LDX #XHI
 BRA SKP0
***************************************************

*GO TO USER PROGRAM ROUTINE
GOTO RTI
OUTEEE BRA OUTEE1



*SAVE IXR AND LOAD IXR WITH CORRECT
*PORT NUMBER AND TEST FOR TYPE
SAVGET STX XTEMP STORE INDEX REGISTER
GETPT1 LDX PORADD
ISACIA PSHB
 LDAB 1,X
 CMPB 3,X
 PULB
 RTS
***************************************************

*CONTINUATION OF SEARCH ROUTINE
SKP0 JSR OUT4HS
 LDX XHI
INCR1 CPX ENDA
 BEQ SWTL1
 INX
 BRA OVE

INEEE1 BSR INCH8 INPUT 8 BIT CHARACTER
 ANDA #%01111111 GET RID OF PARITY BIT
 RTS

BILD INS FIX UP STACK WHEN USING
 INS BINARY LOADER ON SWTPC TAPES
 INS

*INPUT ONE CHAR INTO ACC B
INCH8 PSHB SAVE ACC B
 BSR SAVGET SAVE IXR, GET PORT# AND TYPE
 BNE IN1 INPUT FROM PIA IF NOT
 LDAA #$15 RECONFIG FOR 8 BIT, 1 SB
 STAA 0,X
ACIAIN LDAA 0,X
 ASRA
 BCC ACIAIN NOT READY
 LDAA 1,X LOAD CHAR
 LDAB PORECH
 BEQ ACIOUT ECHO
 BRA RES DON'T ECHO

*OUTPUT ONE CHARACTER
OUTEE1 PSHB SAVE ACC B
 BSR SAVGET
 BNE IOUT

ACIOUT LDAB #$11
 STAB 0,X
ACIOU1 LDAB 0,X
 ASRB
 ASRB
 BCC ACIOU1 ACIA NOT READY
 STAA 1,X OUTPUT CHARACTER
RES PULB RESTORE ACC B
 LDX XTEMP
 RTS

*PIA INPUT ROUTINE
IN1 LDAA 0,X LOOK FOR START BIT
 BMI IN1
 BSR DDL DELAY HALF BIT TIME
 LDAB #4 SET DEL FOR FULL BIT TIME
 STAB 2,X
 ASLB SET UP CNTR WITH 8
IN3 BSR DEL WAIT ONE CHAR TIME
 SEC
 ROL 0,X
 RORA
 DECB
 BNE IN3
 BSR DEL WAIT FOR STOP BIT
 LDAB PORECH IS ECHO DESIRED?
 BEQ IOUT2 ECHO
 BRA RES RESTORE IXR,ACCB
*PIA OUTPUT ROUTINE
IOUT BSR DDL1 DELAY ONE HALF BIT TIME
 LDAB #$A SET UP COUNTER
 DEC 0,X SET START BIT
 BSR DE START TIMER
OUT1 BSR DEL DELAY ONE BIT TIME
 STAA 0,X PUT OUT ONE DATA BIT
 SEC
 RORA SHIFT IN NEXT BIT
 DECB DECREMENT COUNTER
 BNE OUT1 TEST FOR 0
IOUT2 LDAB 2,X TEST FOR STOP BITS
 ASLB SHIFT BIT TO SIGN
 BPL RES BRA FOR 1 STOP BIT
 BSR DEL DELAY FOR STOP BITS
 BRA RES
DEL TST 2,X IS TIME UP
 BPL DEL
DE INC 2,X RESET TIMER
 DEC 2,X
 RTS

DDL CLR 2,X HALF BIT DELAY
DDL1 BSR DE
 BRA DEL


*OPTIONAL PORT ROUTINE
OPTL BSR INEEE1
 TAB
 CLR PORADD+1 SET I/O ADDRESS FOR $8000
 LDX PORADD
 BSR PIAINI INITIALIZE PIA
 BSR PIAECH SET ECHO
 LDX #TABLE1 P, L OR E
 TBA
 JMP OVER LOOK AT TABLE FOR E, L OR P

PIAECH LDAA #$34 SET DDR
 STAA 3,X
 STAA 2,X
NOOPT RTS

*PIA INITIALIZATION ROUTINE
PIAINI INC 0,X SET DDR
 LDAA #$7
 STAA 1,X
 INC 0,X
 STAA 2,X
 RTS

*MINIFLOPPY DISK BOOT
DISK CLR $8014
 BSR DELAY
 LDAB #$0B
 BSR RETT2
LOOP1 LDAB 4,X
 BITB #1
 BNE LOOP1
 CLR 6,X
 BSR RETURN
 LDAB #$9C
 BSR RETT2
 LDX #$2400
LOOP2 BITB #2
 BEQ LOOP3
 LDAA $801B
 STAA 0,X
 INX
LOOP3 LDAB $8018
 BITB #1
 BNE LOOP2
 JMP $2400
RETT2 STAB 4,X
RETURN BSR RETT1
RETT1 RTS

*GENERAL PURPOSE DELAY LOOP
DELAY LDX #$FFFF
DELAY1 DEX
 CPX #$8014 STOP AT 8014
DUM BNE DELAY1
 RTS


*CLRAR SCREEN FOR CT-1024 TYPE TERMINALS
CLEAR LDX #CURSOR
 JSR PDATA1
 BSR DELAY1 DELAY
RDOFF1 JSR RDOFF
 BRA C4

*BREAKPOINT ENTERING ROUTINE
BREAK LDX #SF0
 CPX SWIJMP BREAKPOINTS ALREADY IN USE?
 BEQ INUSE
 INX
BREAK0 BSR STO1
 JSR BADDR
 STX BKPT
 LDAA 0,X
 STAA BKLST
 LDAA #$3F
 STAA 0,X
 LDX #SF0
 BSR STO1
 JMP CONTR1
INUSE LDX BKPT
 LDAA BKLST
 STAA 0,X
 LDX #SFE1
 BRA BREAK0

SWISET STAA STACK+1 FIX POWER UP INTERRUPT
 LDX SWIJMP
 CPX #SF0
 BEQ STORTN
STO LDX #SFE1
STO1 STX SWIJMP
STORTN RTS

PUNCH1 BSR PUNCH
 BRA POFC4

*FORMAT END OF TAPE WITH PGM. CTR. AND S9
PNCHS9 LDX #$A049
 STX ENDA
 DEX
 BSR PUNCH2
 LDX #S9
PDAT JSR PDATA1
POFC4 BSR PNCHOF
 BSR DELAY
C4 JMP CONTRL

RDON COM PORECH DISABLE ECHO FOR ACIA
 LDAA #$11 RON CHAR.
 LDAB #$20 STROBE CHAR
 BSR STROBE
 JSR ISACIA CHECK TO SEE IF PIA
 BEQ RTNN
 LDAA #$3C DISABLE PIA ECHO IF PIA
 STAA 3,X
RTNN RTS

RDOFF LDAA #$13 TURN READER OFF
 LDAB #$10
 BRA STROBE

PNCHON LDAA #$12
 LDAB #4
 BRA STROBE

PNCHOF LDAA #$14
 LDAB #$8

*PIA STROBING ROUTINE FOR PUNCH/READ ON/OFF
STROBE JSR OUTCH
 JSR GETPT1
 BEQ RTN1
 LDAA #2
 ORAB #1
 BSR STR2
 BSR STR1
 LDAA #2
 LDAB #1
 STAB 0,X
 BSR STR2
STR1 LDAA #6
STR2 STAA 1,X
 STAB 0,X
RTN1 RTS

*PUNCH FROM BEGINNING ADDRESS (BEGA) THRU
*ENDING ADDRESS (ENDA)
PUNCH LDX BEGA
PUNCH2 STX TW
 BSR PNCHON
PUN11 LDAA ENDA+1
 SUBA TW+1
 LDAB ENDA
 SBCB TW
 BNE PUN22
 CMPA #16
 BCS PUN23
PUN22 LDAA #15
PUN23 ADDA #4
 STAA BYTECT
 SUBA #3
 STAA TEMP
*PUNCH C/R L/F NULLS S1
 LDX #MTAPE1
 JSR PDATA1
 CLRB
*PUNCH FRAME COUNT
 LDX #BYTECT
 BSR PUNT2 PUNCH 2 HEX CHARACTERS
*PUNCH ADDRESS
 LDX #TW
 BSR PUNT2
 BSR PUNT2
*PUNCH DATA
 LDX TW
PUN32 BSR PUNT2 PUNCH ONE BYTE
 DEC TEMP
 BNE PUN32
 STX TW
 COMB
 PSHB
 TSX
 BSR PUNT2 PUNCH CHECKSUM
 PULB RESTORE STACK
 LDX TW
 DEX
 CPX ENDA
 BNE PUN11
RTN5 RTS

*PUNCH 2 HEX CHAR, UPDATE CHECKSUM
PUNT2 ADDB 0,X
 JMP OUT2H OUTPUT 2 HEX CHAR AND RTS

*COMMAND TABLE
TABLE FCB 'G GOTO
 FDB GOTO
 FCB 'Z GOTO PROM
 FDB PROM
 FCB 'M MEMORY EXAM AND CHANGE
 FDB CHANGE
 FCB 'F BYTE SEARCH
 FDB SEARCH
 FCB 'R REGISTER DUMP
 FDB PRINT
 FCB 'J JUMP
 FDB JUMP
 FCB 'C CLEAR SCREEN
 FDB CLEAR
 FCB 'D DISK BOOT
 FDB DISK
 FCB 'B BREAKPOINT
 FDB BREAK
 FCB 'O OPTIONAL PORT
 FDB OPTL
TABLE1 FCB 'P ASCII PUNCH
 FDB PUNCH1
 FCB 'L ASCII LOAD
 FDB LOAD
TABEND FCB 'E END OF TAPE
 FDB PNCHS9

 ORG $FFF8
 FDB IRQV IRQ VECTOR
 FDB SFE SOFTWARE INTERRUPT
 FDB NMIV NMI VECTOR
 FDB START RESTART VECTOR

*ORG $A048
*FDB START
 END
